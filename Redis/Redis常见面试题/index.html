<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/01.ico"/>
	<link rel="shortcut icon" href="/img/01.ico">
	
			    <title>
    shao.c的博客
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="shao.c" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/01.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">SHAO.C</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Golang/">Golang</a></li><li><a class="category-link" href="/categories/My/">My</a></li><li><a class="category-link" href="/categories/MySQL/">MySQL</a></li><li><a class="category-link" href="/categories/Redis/">Redis</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/My/about/" title="About">
		                About
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/C-QAQ" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://sc-figure-bed.obs.cn-north-4.myhuaweicloud.com/img/20230414232853.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >Redis常见面试题</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2 id="Redis常见数据类型"><a href="#Redis常见数据类型" class="headerlink" title="Redis常见数据类型"></a>Redis常见数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h3><p><strong>内部实现</strong>：int和SDS，SDS 不仅可以保存文本数据，还可以保存二进制数据。</p>
<p><strong>应用场景：</strong>缓存对象、常规计数、分布式锁</p>
<p><strong>常用指令</strong>：SET name lin、GET name、SETNX key value</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><strong>内部实现：</strong> 双向链表或压缩列表，素个数小于 <code>512</code> 个&amp;每个元素的值都小于 <code>64</code> 字节采用压缩列表、否则双向链表。后来用快速链表替代。</p>
<p><strong>应用场景：</strong>消息队列（1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）</p>
<p><strong>常用指令</strong>：LPUSH key value [value …] 、RPUSH key value [value …]、LPOP key  、RPOP key </p>
<h3 id="Hsah"><a href="#Hsah" class="headerlink" title="Hsah"></a>Hsah</h3><p><strong>内部实现</strong>：压缩列表或哈希表，元素个数小于 512 个，所有值小于 64 字节的话，Redis 会使用<strong>压缩列表</strong>；否则哈希表。（压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。）</p>
<p><strong>应用场景：</strong>缓存对象、购物车。</p>
<p><strong>常用指令：</strong>HSET key field value   、HGET key field</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><strong>内部实现</strong>：哈希表或整数集合、元素都是整数且元素个数小于 <code>512</code>使用<strong>整数集合</strong>，否则 Redis 使用<strong>哈希表</strong>。</p>
<p><strong>应用场景：</strong>聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</p>
<p><strong>常用指令：</strong>SADD key member [member …]、SREM key member [member …] </p>
<h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><p><strong>内部实现：</strong>压缩列表或跳表实现、元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>、否则使用跳表（压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。）</p>
<p><strong>应用场景：</strong>排序场景，比如排行榜、电话和姓名排序等。</p>
<p><strong>常用指令：</strong>ZADD key score member [[score member]…]   、ZREM key member [member…]    、ZRANGE key start stop [WITHSCORES]</p>
<h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p><strong>内部实现</strong>：是一串连续的二进制数组（0和1），表示某个元素的值或者状态，时间复杂度为O(1)。</p>
<p><strong>应用场景</strong>：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等</p>
<p><strong>常用指令：</strong>SETBIT key offset value、GETBIT key offset</p>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p><strong>内部实现：</strong>提供不精确的去重计数。</p>
<p><strong>应用场景：</strong>海量数据基数统计的场景，比如百万级网页 UV 计数等；</p>
<p><strong>常用指令：</strong>PFADD key element [element …]、PFCOUNT key [key …]</p>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p><strong>应用场景：</strong>存储地理位置信息的场景，比如滴滴叫车；</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p><strong>应用场景</strong>：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>SDS</strong>：SDS获取字符串的长度时间复杂度是O1,并且可以存储任意类型的数据。</p>
<p><strong>压缩列表：</strong></p>
<ul>
<li>由连续内存块组成的顺序型数据结构，节省内存但是，查询没那么高效了。</li>
<li>prevlen 属性都记录了「前一个节点的长度」，所以会有连锁更新，导致每个元素都得重新分配内存。</li>
</ul>
<p><strong>哈希表：</strong>采用链式哈希解决哈希冲突。</p>
<p><strong>渐进式rehash</strong>：在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</p>
<p><strong>跳表：</strong>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)。链表基础上改进过来的，实现了一种「多层」的有序链表。</p>
<ul>
<li><p>在做范围查找的时候，跳表比平衡树操作要简单</p>
</li>
<li><p>从算法实现难度上来比较，跳表比平衡树要简单得多</p>
</li>
</ul>
<p><strong>quicklist</strong>: 双向链表每个节点都是一个压缩列表，控制压缩列表的大小，避免连锁更新</p>
<p><strong>listpack</strong>: 双向链表，每个节点都是压缩列表，但是却掉了prevlen字段，就不会出现连锁更新。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h3 id="Redis大key对Redis有什么影响"><a href="#Redis大key对Redis有什么影响" class="headerlink" title="Redis大key对Redis有什么影响"></a>Redis大key对Redis有什么影响</h3><ul>
<li>创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。</li>
<li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量</li>
<li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li><strong>内存分布不均</strong>。集群模型下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多。</li>
</ul>
<h2 id="过期删除和内存淘汰机制"><a href="#过期删除和内存淘汰机制" class="headerlink" title="过期删除和内存淘汰机制"></a>过期删除和内存淘汰机制</h2><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><ul>
<li>定时删除；</li>
<li>惰性删除；</li>
<li>定期删除：每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</li>
</ul>
<p>redis是采用惰性删除+定期删除实现的。</p>
<h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><p><em>不进行数据淘汰的策略</em></p>
<p><em>进行数据淘汰的策略</em></p>
<ul>
<li>置了过期时间的数据中进行淘汰<ul>
<li>随机删除</li>
<li>lru</li>
<li>lfu</li>
<li>删除更早过期的</li>
</ul>
</li>
<li>所有数据范围内进行淘汰<ul>
<li>随机</li>
<li>lru</li>
<li>lfu</li>
</ul>
</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ul>
<li>第一阶段是建立链接、协商同步<ul>
<li>从服务器会主动发送请求要同步数据：<strong>主服务器的 runID</strong> 和<strong>复制进度 offset</strong>。</li>
</ul>
</li>
<li>第二阶段是主服务器同步数据给从服务器：<ul>
<li>生成 RDB 文件，然后把文件发送给从服务器。</li>
<li>从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件。</li>
<li>为了保证主从服务器的数据一致性，<strong>主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲</strong>：<ul>
<li>主服务器生成 RDB 文件期间；</li>
<li>主服务器发送 RDB 文件给从服务器期间；</li>
<li>「从服务器」加载 RDB 文件期间；</li>
</ul>
</li>
</ul>
</li>
<li>第三阶段是主服务器发送新写操作命令给从服务器。</li>
</ul>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：</p>
<ul>
<li>如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>增量同步</strong>的方式；</li>
<li>相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>全量同步</strong>的方式。</li>
</ul>
<h3 id="主从复制共有三种模式："><a href="#主从复制共有三种模式：" class="headerlink" title="主从复制共有三种模式："></a>主从复制共有三种模式：</h3><p>全量复制、基于长连接的命令传播、增量复制。</p>
<h3 id="集群脑裂"><a href="#集群脑裂" class="headerlink" title="集群脑裂"></a>集群脑裂</h3><p>主节点失联，但是仍在处于服务状态，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在从节点中选举出一个 leeder 作为主节点，这时集群就有两个主节点了 —— <strong>脑裂出现了</strong>。</p>
<p>解决：设置两个参数，链接数和发送延迟。</p>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><ul>
<li>监控</li>
<li>选主</li>
<li>通知</li>
</ul>
<h3 id="如何判断主节点真的故障了？"><a href="#如何判断主节点真的故障了？" class="headerlink" title="如何判断主节点真的故障了？"></a>如何判断主节点真的故障了？</h3><p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。</p>
<ul>
<li>一个哨兵判断主节点主管下线，通知其他哨兵节点进行投票</li>
<li>最终判断是否客观下线</li>
</ul>
<h3 id="由哪个哨兵进行主从故障转移？"><a href="#由哪个哨兵进行主从故障转移？" class="headerlink" title="由哪个哨兵进行主从故障转移？"></a>由哪个哨兵进行主从故障转移？</h3><ul>
<li>在哨兵集群中选出一个 leader，让 leader 来执行主从切换。</li>
<li>哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者</li>
<li>候选者会向其他哨兵发送命令，进行投票。<ul>
<li>第一，拿到半数以上的赞成票；</li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li>
</ul>
</li>
</ul>
<h3 id="主从故障转移的过程是怎样的？"><a href="#主从故障转移的过程是怎样的？" class="headerlink" title="主从故障转移的过程是怎样的？"></a>主从故障转移的过程是怎样的？</h3><ul>
<li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。</li>
<li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li>
<li>第三步：将新主节点的 IP 地址和信息，通过「发布者&#x2F;订阅者机制」通知给客户端；</li>
<li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li>
</ul>
<p><strong>哨兵节点之间是通过 Redis 的发布者&#x2F;订阅者机制来相互发现的</strong>。</p>
<h3 id="缓存雪崩、缓存击穿、缓存穿透"><a href="#缓存雪崩、缓存击穿、缓存穿透" class="headerlink" title="缓存雪崩、缓存击穿、缓存穿透"></a>缓存雪崩、缓存击穿、缓存穿透</h3><p><strong>缓存雪崩</strong>：</p>
<ul>
<li>均匀设置过期时间；</li>
<li>互斥锁；</li>
<li>双 key 策略；</li>
<li>后台更新缓存；</li>
</ul>
<p><strong>缓存击穿：</strong></p>
<ul>
<li>采用互斥锁</li>
<li>不给热点数据设置过期时间或者是在热点数据快要过期的时候重新设置过期时间。</li>
</ul>
<p><strong>缓存穿透：</strong></p>
<ul>
<li>第一种方案，非法请求的限制；</li>
<li>第二种方案，缓存空值或者默认值；</li>
<li>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；<ul>
<li>底层实际上是基于哈希的一种数据结构，【一个比特数组+N个哈希函数】</li>
<li>key通过N个哈希函数计算N个值，这N个值%比特数组长度，将对应的位置设置成1。</li>
<li>下次再查询元素时，通过检测对应位置是否都是1，如果都是1，说明在数据库中，否则不在数据库中。</li>
</ul>
</li>
</ul>
<h2 id="redis集群之间通过什么联系"><a href="#redis集群之间通过什么联系" class="headerlink" title="redis集群之间通过什么联系"></a>redis集群之间通过什么联系</h2><ul>
<li>Redis的集群是通过gossip协议进行节点之间的联系的。Gossip协议是一种去中心化的协议，通过节点之间相互通信的方式来维护整个集群的状态。</li>
<li>在Redis集群中，每个节点都会维护一个关于整个集群状态的视图，这个视图包含了当前集群中所有节点的信息。每个节点都会定期将自己的视图发送给其他节点，并接收其他节点发送过来的视图，通过比较视图的差异来同步集群状态。</li>
<li>当一个节点加入集群时，它会随机选择一个已知的节点作为自己的种子节点，通过种子节点来了解整个集群的状态并加入集群。当一个节点离开集群时，其他节点会检测到它的离开，并从集群中删除它。<br>通过gossip协议，Redis集群可以实现自动化的节点发现、故障恢复和数据迁移，保证了集群的高可用性和可扩展性。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="Redis如何实现分布式锁？可重入性怎么实现？请求计数器怎么存贮的？"><a href="#Redis如何实现分布式锁？可重入性怎么实现？请求计数器怎么存贮的？" class="headerlink" title="Redis如何实现分布式锁？可重入性怎么实现？请求计数器怎么存贮的？"></a>Redis如何实现分布式锁？可重入性怎么实现？请求计数器怎么存贮的？</h4><p>Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> lock_key unique_value NX PX <span class="number">10000</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>lock_key 就是 key 键；</li>
<li>unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；</li>
<li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li>
<li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li>
</ul>
<p>可重入性：</p>
<ul>
<li>锁作为键，请求方的标识作为值</li>
<li>通过比较请求方标识和存储在Redis中的值是否一致来区分不同的请求方。</li>
</ul>
<p>请求计数器可以通过在Redis中存储一个计数器来实现。每次获取锁成功后，将计数器加1，释放锁时将计数器减1。如果计数器的值为0，则表示锁已经完全释放。</p>
<h4 id="Redis是什么？简述它的优点？"><a href="#Redis是什么？简述它的优点？" class="headerlink" title="Redis是什么？简述它的优点？"></a>Redis是什么？简述它的优点？</h4><ul>
<li>Redis是一种内存数据库，也可以称为键值存储数据库。它将所有数据存储在内存中，因此读写速度非常快。常用于<strong>缓存，消息队列、分布式锁等场景</strong>。</li>
<li>Redis支持多种数据类型和数据结构，包括字符串、哈希、列表、集合和有序集合等。支持<strong>事务 、持久化</strong>、<strong>主从复制模式、哨兵模式、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制</strong>。</li>
</ul>
<p>优点：</p>
<ol>
<li>高性能：Redis数据存储在内存中，读写速度非常快，同时支持多种复杂数据类型和数据结构操作，能够快速处理大量数据。</li>
<li>数据持久化：Redis支持数据持久化，可以将数据保存在硬盘上，防止数据丢失。</li>
<li>分布式：Redis可以通过复制和分片等方式实现分布式部署，可以横向扩展，提高系统的性能和可靠性。</li>
<li>多种数据结构：Redis支持多种数据结构和数据类型，包括字符串、哈希、列表、集合和有序集合等，非常灵活。</li>
<li>丰富的功能：Redis支持多种功能和命令，例如事务、持久化、复制、发布订阅和Lua脚本等，能够满足各种应用场景的需求。</li>
</ol>
<h4 id="Redis的数据结构有哪些？"><a href="#Redis的数据结构有哪些？" class="headerlink" title="Redis的数据结构有哪些？"></a>Redis的数据结构有哪些？</h4><p>如上：Redis常见数据类型</p>
<h4 id="为什么要用-Redis-做缓存？"><a href="#为什么要用-Redis-做缓存？" class="headerlink" title="为什么要用 Redis 做缓存？"></a>为什么要用 Redis 做缓存？</h4><ol>
<li>高性能：Redis将数据存储在内存中，因此读写速度非常快，能够快速处理大量数据，提高应用程序的响应速度和吞吐量。</li>
<li>高并发：Redis虽然是单线程，但是Redis支持多线程并发访问和处理，能够处理大量的请求，提高系统的并发能力。</li>
<li>数据持久化：Redis支持数据持久化，可以将数据保存在硬盘上，防止数据丢失，保证数据的安全性和可靠性。</li>
<li>多种数据结构：Redis支持多种数据结构和数据类型，包括字符串、哈希、列表、集合和有序集合等，非常灵活。</li>
<li>缓存失效机制：Redis支持设置缓存失效时间和策略，能够及时清除过期数据，避免缓存数据的脏读和脏写。</li>
<li>分布式：Redis可以通过复制和分片等方式实现分布式部署，可以横向扩展，提高系统的性能和可靠性。</li>
</ol>
<h4 id="Redis的缓存不一致问题有哪些？"><a href="#Redis的缓存不一致问题有哪些？" class="headerlink" title="Redis的缓存不一致问题有哪些？"></a>Redis的缓存不一致问题有哪些？</h4><p><strong>如果是保证数据库和缓存的一致性：</strong></p>
<p>常见的缓存更新策略共有3种：</p>
<ol>
<li>Cache Aside（旁路缓存）策略；</li>
<li>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略；</li>
<li>Write Back（写回）策略；</li>
</ol>
<p><strong>旁路缓存</strong>：</p>
<p>写策略的步骤：</p>
<ul>
<li>先更新数据库中的数据，再删除缓存中的数据。</li>
</ul>
<p>*<em><strong>读策略的步骤</strong>：</em>*</p>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据；</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li>
</ul>
<p>读穿写穿：</p>
<p>读穿：</p>
<p>先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。</p>
<p>写穿：</p>
<p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p>
<ul>
<li>如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li>
<li>如果缓存中数据不存在，直接更新数据库，然后返回；</li>
</ul>
<p><strong>Write Back（写回）策略</strong>：</p>
<p>Write Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</p>
<h3 id="以上是缓存如何更新到数据库的问题的"><a href="#以上是缓存如何更新到数据库的问题的" class="headerlink" title="以上是缓存如何更新到数据库的问题的"></a>以上是缓存如何更新到数据库的问题的</h3><h3 id="以下是如何解决缓存不一致问题？"><a href="#以下是如何解决缓存不一致问题？" class="headerlink" title="以下是如何解决缓存不一致问题？"></a>以下是如何解决缓存不一致问题？</h3><p>更新策略</p>
<ol>
<li>先更新数据库，再更新缓存<ul>
<li>线程A更新数据库（i&#x3D; 1)</li>
<li>线程B更新数据库（i &#x3D; 2)</li>
<li>线程B更新缓存（i &#x3D; 2）；</li>
<li>线程A更新缓存（i &#x3D; 1）；</li>
</ul>
</li>
<li>先更新缓存，再更新数据库</li>
</ol>
<p>这两种如果有一个更新失败都会造成数据不一致的情况。第二种情况：如果更新缓存成功，数据库更新失败，此时发生不一致，缓存中的是脏数据。还不如删除缓存。</p>
<p>删除缓存的两种策略</p>
<ol>
<li><p>先删除缓存，再更新数据库</p>
<ul>
<li>线程 A 要更新i &#x3D; 2（旧值 i &#x3D; 1）</li>
<li>线程 A 先删除缓存；</li>
<li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（i &#x3D; 1）；</li>
<li>线程 A 将新值写入数据库（i &#x3D; 2）</li>
<li>线程 B 将旧值写入缓存（i &#x3D; 1）；</li>
</ul>
<p>解决这种缓存值是旧值可以用延迟双删策略</p>
<ol>
<li><strong>先删除缓存；</strong></li>
<li><strong>再写数据库；</strong></li>
<li><strong>休眠一段时间；</strong></li>
<li><strong>再次删除缓存；</strong></li>
</ol>
<p>设置缓存过期时间：</p>
<p>所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值，然后再写入缓存中；</p>
</li>
<li><p>先更新数据库，再删除缓存</p>
<p>线程A需要修改数据，update user set name &#x3D; ‘李四’ where id &#x3D; 1，数据更新完成后，在删除缓存的时候，数据库宕机或者服务宕机，导致没有删除掉缓存，此时数据库和缓存的数据也会出现不一致，数据库中是新数据，缓存还是旧数据。</p>
<p>或者：</p>
<ul>
<li>缓存已经过期</li>
<li>A查询数据库获取一个旧值</li>
<li>B写数据库新值</li>
<li>B删除缓存</li>
<li>A跟新旧值到缓存</li>
</ul>
</li>
</ol>
<p>都可以采用设置过期时间来解决，或者延迟双删来解决。</p>
<p>还有一些：</p>
<ol>
<li>消息队列补偿<br>删除牛败的消息打入队列，监听队列，再次重试执行。</li>
<li>用canal监听binlog<br>当mysql的数据发生变化后，canal会受到一条消息,这时候进行删除。好处是可以代码解耦。减少业务复杂度。并旦中间件保证了我们的高可用性。</li>
</ol>
<h4 id="如何解决Redis的缓存不一致性问题？"><a href="#如何解决Redis的缓存不一致性问题？" class="headerlink" title="如何解决Redis的缓存不一致性问题？"></a>如何解决Redis的缓存不一致性问题？</h4><ol>
<li>如何用Redis的BitMaps实现签到功能？具体设计讲一下？</li>
<li>除了redis之外还了解哪些中间件？</li>
</ol>
<h2 id="redis实战"><a href="#redis实战" class="headerlink" title="redis实战"></a>redis实战</h2>
            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://c-qaq.github.io/Redis/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://c-qaq.github.io/Redis/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
        <!-- <div id="copyright">
    <ul>
        <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
        <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech" style="border-bottom: none;">miccall</a></li>
    </ul>
    
        <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    
</div> -->
    </div>
</body>



 	
</html>
